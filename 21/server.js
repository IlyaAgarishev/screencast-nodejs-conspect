// Использование потоков для работы с сетевыми соединениями
var http = require('http');
var fs = require('fs');

new http.Server(function(req, res) {
  // res instanceof http.ServerResponse < stream.Writable

  if (req.url == '/big.html') {
    // readSteam - буит входным потоком данных, а выходным - объект ответа res, который явл объкетом класса
    // http.ServerResponse на следудущем от stream.Writable
    var file = new fs.ReadStream('big.html');
    // ф-ия sendFile буит принимать один поток для файла и второй поток для ответа
    sendFile(file, res);
  }
}).listen(3000);

function sendFile(file, res) {
  // ждем данные
  file.on('readable', write);

  function write() {
    // потом читаем эти данные
    //----------------------- считать
    var fileContent = file.read();

    // и затем отправляем эти данные в ответ
    // Это плохая идея, так как если клиент не может получить эти данные, например если у него медленная скорость
    // соединения, то они зависнут в буфере объекта res. Таким образом если файл очень быстро считан, но пока не
    // отправлен - то он займет большое кол-во памяти
    // res.write(fileContent);

    // Универсальное решение
    // Перед отправкой мы анализируем что это вызов вернет !res.write(fileContent) - если res принимает данные очень
    // быстро, то res.write(fileContent) будет возвращать true. Это означает, что ветка if никогда не выполниться
    // => мы получим read/write/read/write/read/write
    // Если res.write(fileContent) == false - это значит, что буффер переполнен
    //----------------------- отправить
    if (fileContent && !res.write(fileContent)) {
      // Если он переполнен, то мы времено отказываемся обрабатывать событие readable, но это не значит, что файловый
      // поток перестанет читать данные. Он их буит читать, но он дочитает их до определенного уровня, заполнит свой
      // внутрениий буффер объекта file и затем, он останется заполнен на определенном уровне, то есть файловый поток
      // что-то считает и там застопориться.
      file.removeListener('readable', write);
      // Далее мы дождемя события drain, то есть когда данные будут успешно отданы в ответ
      //----------------------- при необходимости подождать drain
      res.once('drain', function() {
        file.on('readable', write);
        write();
      });
    }
  }

  // По окончанию файла наступит событие end
  file.on('end', function() {
    // Таким образом будет закрыто исходящее соединение
    res.end();
  });
}
